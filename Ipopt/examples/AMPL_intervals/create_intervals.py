import subprocess
import sys
import random
import matplotlib.pyplot as plt
import argparse
import time
from matplotlib.patches import Rectangle
from pylab import *

#parser = argparse.ArgumentParser(description='Run AMPL/IpOpt Intervalization
#parser.add_argument('nloops',nargs=1,type=int)
#parser.add_argument('-bm',nargs=1,type=int)
#parser.add_argument('-s',nargs=1,type=int)
#parser.add_argument('-bv',nargs=1,type=int)

class Interval:
    """Representation of upper and lower bound"""
    def __init__(self, pL, pU):
        assert(len(pL)==len(pU))
        self.pL = pL
        self.pU = pU

    def split(self, idx):
        """
        split an interval along the variable dimension idx (in 0based notation)

        in: idx, parameter index to split,
        out: 2 intervals resulting from split
        """
        p1L = []
        p1U = []
        p2L = []
        p2U = []
        for k, (pLv, pUv) in enumerate(zip(self.pL, self.pU)):
            p1L.append(pLv)
            p2U.append(pUv)
            if k==idx:
                v = 0.5*(pLv+pUv)
                p1U.append(v)
                p2L.append(v)
            else:
                p1U.append(pUv)
                p2L.append(pLv)
        return Interval(p1L, p1U), Interval(p2L, p2U)

    def plot(self, dim):
        n = dim[0]
        m = dim[1]
        print self.pL[n]
        rect = Rectangle((self.pL[n], self.pL[m]), self.pU[n]-self.pL[n], self.pU[m]-self.pL[m])
        plt.gca().add_artist(rect)

    def __str__(self):
        s = ''
        for pl, pu in zip(self.pL, self.pU):
            s += '{}, {}\n'.format(pl, pu)
        return s

    def __len__(self):
        return len(self.pL)

class AmplSet:
    """an ampl setup: ampl srcipt and feasible set of intervals"""
    def __init__(self, ampl_script, pLnames, pUnames, pLvalues, pUvalues,bm,sc,bv,ctrl_type,ctrl,algo,n_max,gmr_tol,idx):
        self.ampl_script = ampl_script
        self.pLnames = pLnames
        self.pUnames = pUnames
        self.pLvalues = pLvalues
        self.pUvalues = pUvalues
        self.intervals = [Interval(pLvalues, pUvalues)]
        self.branchmode = bm
        self.scaling = sc
        self.benefits = bv
        self.algorithm = algo
        self.control = ctrl
        self.ctype = ctrl_type
        self.nm = n_max
        self.gt = gmr_tol
        self.q = idx
        self.split_sizes = []
        self.split_ints = []
        self.outputname = str(self.q)+'_bm'+str(self.branchmode)+'_s'+str(self.scaling)+'_bv'+str(self.benefits)+'_'

    def write_include_file(self, filename='intervals.inc'):
        """write current intervallization data into ampl include file"""
        f = open(filename, 'w')
        nint = len(self.intervals)
        f.write('#file generated by sIpOpt intervallization routine script create_intervals.py -- Ben Waldecker Sep 2012\n\n');
        f.write('let nint := {};\n'.format(nint))
        for k,(nameL, nameU) in enumerate(zip(self.pLnames, self.pUnames)):
            f.write('let {{q in 1..{} }} {}[q].intervalID := q;\n'.format(nint, nameL))
            f.write('let {{q in 1..{} }} {}[q].intervalID := q;\n'.format(nint, nameU))
            f.write('let {{q in 1..{} }} {}[q].parameter := {};\n'.format(nint,nameL, k+1))
            f.write('let {{q in 1..{} }} {}[q].parameter := {};\n'.format(nint, nameU, k+1))

        for k, iv in enumerate(self.intervals):
            for nameL, pL, nameU, pU in zip(self.pLnames, iv.pL, self.pUnames, iv.pU):
                f.write('let {}[{}] := {};\n'.format(nameL, k+1, pL))
                f.write('let {}[{}] := {};\n'.format(nameU, k+1, pU))
        f.write('\n\n#end of file');
        f.close()

    def write_opt_file(self):
        """write specified options into ipopt.opt file"""
        f = open('ipopt.opt', 'w')
        f.write('#file generated by sIpOpt intervallization routine script create_intervals.py -- Ben Waldecker Sep 2012\n\n');
        options = self.create_optionstring(self.branchmode,self.scaling,self.benefits,self.algorithm,self.control,self.ctype,self.nm,self.gt)
        f.write(options)
        f.write('\n\n#end of file\n');
        f.close()


    def write_splits_from_data(self,split_file,ints,pars):
        """write succession of interval and parameter splits into splits_...txt file"""
        f = open(split_file, 'w')
        f.write('#file generated by sIpOpt intervallization routine script create_intervals.py -- Ben Waldecker Sep 2012\n\n');
        for (i,p) in zip(ints,pars):
            f.write('intervalID: ' +str(i+1) +' parameter: ' +str(p+1) +'\n')
        f.write('\n\n#end of file\n');
        f.close()


    def write_splits_from_files(self,split_file,branch_file):
        """read succession of interval and parameter splits from branch and split files and write into splits_...txt file"""
        (nint,npar,nasd) = self.read_branch(branch_file)
        (nints,npars,nasd) = self.read_branch(split_file)
        nints.append(nint[0])
        npars.append(npar[0])
        f = open(split_file, 'w')
        f.write('#file generated by sIpOpt intervallization routine script create_intervals.py -- Ben Waldecker Sep 2012\n\n');
        for (i,p) in zip(nints,npars):
            f.write('intervalID: ' +str(i+1) +' parameter: ' +str(p+1) +'\n')
        f.write('\n\n#end of file\n');
        f.close()

    def create_optionstring(self,bm,sc,bv,alg,ctrl,ctrlt,nm,gt):
        """
        write specified options into ipopt.opt compatible string

        in: bm, integer specifying branchmode setting (1:larger 2:smaller 3:absolute_larger, default 2)
        in: sc, integer specifying scaling setting (1: no scaling, 2: scale with relative int width, 3: scale with int width, default 2)
        in: bv, integer specifying benefit value tpye (1: single bound evaluation, 2: scalar product evaluation, default 2)
        """
        if bm==1:
            branchmode = 'branchmode largest\n'
        elif bm==3:
            branchmode = 'branchmode abs_largest\n'
        else:
            branchmode = 'branchmode smallest\n'
        if sc==1:
            scaling = 'scalingmode none\n'
        elif sc==3:
            scaling = 'scalingmode interval_widths\n'
        elif sc==4:
            scaling = 'scalingmode reverse_interval_widths\n'
        elif sc==5:
            scaling = 'scalingmode reverse_total_widths\n'
        else:
            scaling = 'scalingmode total_interval_widths\n'
        if bv == 1:
            branchvalue = 'branchvalue bound\n'
        else:
            branchvalue = 'branchvalue product\n'
        if alg == 'control':
            algorithm = 'sensemode control\n'
        elif alg == 'MINRES':
            algorithm = 'sensemode MINRES\n'
        elif alg == 'finiRES':
            algorithm = 'sensemode finiRES\n'
        else:
            algorithm = 'sensemode GMRES\n'

        control = ctrl +' '
        ctype = str(ctrlt) +'\n'
        n_max = 'gmr_n_max ' +str(nm) +'\n'
        gmr_tol = 'gmr_tol ' +str(gt) +'\n'
        retval = branchmode+scaling+branchvalue
        retval += algorithm+control+ctype
        retval += n_max+gmr_tol

    ### hard coding lower mu value
        retval += 'mu_target '+str(1.0e-6) +'\n'
        return retval

    def call_ampl(self, output_file_handle=None):
        """"
        one run of ampl

        write inc file, write opt file and run ampl/ipopt with the specified setup
        """
        self.write_include_file()
        self.write_opt_file()
        try:
            subprocess.check_call(['ampl', self.ampl_script], stdout=output_file_handle)
        except subprocess.CalledProcessError as e:
            print e
            sys.exit(1)

    def split(self, interval_idx, para_idx):
        """split interval at interval_idx with respect to parameter para_idx"""
        split_interval = self.intervals.pop(interval_idx)
        self.split_ints.append(split_interval);
        if interval_idx < len(self.intervals)-2:
            self.split_sizes.append(2)
        else:
            self.split_sizes.append(1)
        interval1, interval2 = split_interval.split(para_idx)
        self.intervals.extend([interval1, interval2])

    def undo_splits(self, ns=1):
        """undo the last ns splits - default is one"""
        for ir in range(ns):
            for ic in range(self.split_sizes(len(self.split_sizes)-1)):
                self.intervals.pop(len(self.intervals)-1)
            self.intervals.append(self.split_ints.pop(len(self.split_ints)-1))

    def randomize(self,nruns):
        """randomly split nruns times"""
        for ir in range(nruns):
            output_f = open('output'+str(ir)+'.txt', 'w')
            self.call_ampl(output_file_handle=output_f)
            output_f.close()
            nint = random.randint(0,(len(self.intervals)-1))
            npar = random.randint(0,(len(self.pLnames)-1))
            self.split(nint,npar)


    def branch_controlwise(self,nruns,i_start=0):  #    def branch_controlwise(self,nruns):
        """read control sensitivity data starting at interval i_start and split specified interval n_runs time """
#        minBvalues = []
        s_file = 'splits_'+self.outputname+'.txt'
        if i_start is not 0:
            (nint,npar,n_data)=self.read_branch(s_file,i_start)
            for (i,p) in zip(nint,npar):
                self.split(i,p)
            self.write_splits_from_data(s_file,nint,npar)
        else:
            n_data = 0
            f = open(s_file,'w')
            f.close()

        for ir in range(nruns):
            print("\ncreate_intervals.py: run " + str(ir+n_data) + " started.")
            localtime = time.asctime( time.localtime(time.time()) )
            print "Time :", localtime
            output_f = open(self.outputname+str(ir+n_data)+'.txt', 'w')
            self.call_ampl(output_file_handle=output_f)
            output_f.close()
#            minBvalues.append(self.read_results(self.outputname+str(ir)+'.txt'))
            branch_file_handle = 'branch_intervals.dat'
            (nint,npar,dmu)=self.read_branch(branch_file_handle)
            for (i,p) in zip(nint,npar):
                self.split(i,p)
            self.write_splits_from_files(split_file=s_file,branch_file=branch_file_handle)

#            self.plot(dim=[0,1], filename=self.outputname+str(ir)+'_intervalplot.png')
#        print minBvalues
#        minB = np.linspace(minBvalues(0),minBvalues(len(minBvalues)-1),256,endpoint=true)
#        filename=self.outputname+str(ir)+'_minBplot.png'
        # plt.figure(2)
        # plt.plot(minBvalues)
        # plt.hold(True)
        # if filename is not None:
        #     plt.savefig(filename)

    def read_branch(self,fname,n_ints=0):
        """
        read interval data from specified file fname

        in: fname, full name of to be read file
            n_ints, number of splits to be read
        out: tuple of intervalID(s) and parameter index(es) to be split (0based notation)
        """
        pars = []
        ints = []
        n_data = n_ints
        input_f = open(fname)
        for tmp_line in input_f:
            if 'parameter' in tmp_line:
                (int_part,dummy,npar) = tmp_line.partition('parameter: ')
                (dummy1,dummy2,nint) = int_part.partition('intervalID: ')
                pars.append(int(npar)-1)
                ints.append(int(nint)-1)
                if n_ints is not 0:
                    n_ints = n_ints-1
                    if n_ints==0:
                        break
        input_f.close()
        return (ints,pars,n_data-n_ints)

    def read_results(self,fname):
        input_f = open(fname)
        input_f.seek(-128,2)
        for tmp_line in input_f:
            if 'xBmin =' in tmp_line:
                (dummy,dummy,postequal) = tmp_line.partition('= ')
                (value,dummy,dummy) = postequal.partition('\n')
        input_f.close()
        return value

    def plot(self, dim=[0,1], filename=None):
        plt.figure(1)
        min0 = min([i.pL[dim[0]] for i in self.intervals])
        min1 = min([i.pL[dim[1]] for i in self.intervals])
        max0 = max([i.pU[dim[0]] for i in self.intervals])
        max1 = max([i.pU[dim[1]] for i in self.intervals])
        plt.gca().set_xlim(min0, max0)
        plt.gca().set_ylim(min1, max1)
        plt.hold(True)
        for i in self.intervals:
            i.plot(dim)
        if filename is not None:
            plt.savefig(filename)

def run():
    for q,(pLvalues,pUvalues) in enumerate([ ([0.8,0.8],[1.2,1.2])]):
#    for q,(pLvalues,pUvalues) in enumerate([ ([0.8],[1.2])]):

#  , ([0.2,0.2],[1.8,1.8]), ([0.1,0.1],[1.9,1.9]) ]):

#        for (bm,sc,bv) in [(3,2,2),(2,2,2),(3,2,1)]:

        for bm in [2]:
            for bv in [2]:
                for sc in [5]:
                    ampl_script = 'autorandomintervals.run'
#                    ampl_script = 'nobounds.run'
#                    ampl_script = 'tiny.run'
                    pLnames = ['p1L', 'p2L']
                    pUnames = ['p1U', 'p2U']
#                    pLnames = ['pL']
#                    pUnames = ['pU']
#        pLvalues = [0.3, 0.3]
#        pUvalues = [1.8, 1.8]
                    ctrl = 0
                    ctrlt = 'ctrl_index'
                    # MINRES at the moment- not weirdRES
#                    alg = 'MINRES'
                    alg = 'GMRES'
#                    alg = 'finiRES'
#                    alg = 'control'
                    n_max = 2000;
                    gmr_tol = 1.0e-6;
                    info = AmplSet(ampl_script, pLnames, pUnames, pLvalues, pUvalues,bm,sc,bv,ctrl,ctrlt,alg,n_max,gmr_tol,q)
#                    info.randomize(2)
                    info.branch_controlwise(1,16)

    localtime = time.asctime( time.localtime(time.time()) )
    print "Time :", localtime


if __name__=='__main__':
    run()




